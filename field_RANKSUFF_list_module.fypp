#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_${RANK}$${SUFF}$_LIST_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK], kinds=['JP' + str (SUFF)])
#:set ft = fieldTypeList[0]

#:if ft.rank > 2

#:set fieldTypeList = fieldType.getFieldTypeList (ranks=[RANK-1], kinds=['JP' + str (SUFF)])
#:set ft1 = fieldTypeList[0]

USE FIELD_BASIC_MODULE
USE ${ft.name}$_MODULE
USE ${ft1.name}$_MODULE
USE DEV_ALLOC_MODULE

${fieldType.useParkind1 ()}$

IMPLICIT NONE

PRIVATE

#:set ftn = ft.name
#:set ftn1 = ft1.name
TYPE, EXTENDS (${ftn}$_WRAPPER) :: ${ftn}$_LIST_WRAPPER
  TYPE (${ftn1}$_PTR), POINTER :: CHILDREN (:) => NULL ()
CONTAINS
  PROCEDURE :: INIT => ${ftn}$_LIST_WRAPPER_INIT
  PROCEDURE :: FINAL => ${ftn}$_LIST_WRAPPER_FINAL
  PROCEDURE :: DELETE_DEVICE => ${ftn}$_LIST_WRAPPER_DELETE_DEVICE
  PROCEDURE :: ${ftn}$_LIST_WRAPPER_FINAL
  PROCEDURE :: SET_CHILD_DEVPTR => ${ftn}$_SET_CHILD_DEVPTR
END TYPE ${ftn}$_LIST_WRAPPER

PUBLIC :: ${ftn}$_LIST_WRAPPER

CONTAINS

  SUBROUTINE ${ftn}$_LIST_WRAPPER_INIT(SELF, DATA, PERSISTENT, LBOUNDS)
    CLASS(${ftn}$_LIST_WRAPPER), INTENT(INOUT) :: SELF
    ${ft.type}$, TARGET, INTENT(IN) :: DATA(${ft.shape}$)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${ft.rank}$)
    LOGICAL :: LLPERSISTENT
    INTEGER (KIND=JPIM) :: IFLR, JFLD, NFLD
    INTEGER (KIND=JPIM) :: LLBOUNDS (${ft.rank}$)
    CLASS (${ftn1}$_WRAPPER), POINTER :: YLFW

  
    CALL SELF%${ftn}$_WRAPPER%INIT (DATA=DATA, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)

    LLBOUNDS = 1
    IF (PRESENT (LBOUNDS)) LLBOUNDS = LBOUNDS

    IFLR = ${ft.rank}$-1
    NFLD = SIZE (DATA, IFLR)

    LLBOUNDS(IFLR) = LLBOUNDS (IFLR+1)
    ALLOCATE (SELF%CHILDREN (NFLD))
    
#:set ar = ', '.join ([':'] * (ft.rank-2))

    DO JFLD = 1, NFLD
      ALLOCATE (YLFW)
      CALL YLFW%INIT (DATA=DATA(${ar}$, JFLD, :), PERSISTENT=PERSISTENT, LBOUNDS=LLBOUNDS(1:IFLR))
      SELF%CHILDREN (JFLD)%PTR => YLFW
    ENDDO
    
  END SUBROUTINE ${ftn}$_LIST_WRAPPER_INIT

  SUBROUTINE ${ftn}$_LIST_WRAPPER_FINAL(SELF)
    CLASS(${ftn}$_LIST_WRAPPER) :: SELF
    ${ft.type}$, POINTER :: PTR(${ft.shape}$)
    INTEGER (KIND=JPIM) :: JFLD

    DO JFLD = 1, SIZE (SELF%CHILDREN)
      CALL SELF%CHILDREN(JFLD)%PTR%FINAL ()
      DEALLOCATE (SELF%CHILDREN(JFLD)%PTR)
      NULLIFY (SELF%CHILDREN(JFLD)%PTR)
    ENDDO
  
    DEALLOCATE (SELF%CHILDREN)  
    NULLIFY (SELF%CHILDREN)  

    CALL SELF%${ftn}$_WRAPPER%FINAL ()

  END SUBROUTINE ${ftn}$_LIST_WRAPPER_FINAL

  SUBROUTINE ${ftn}$_LIST_WRAPPER_DELETE_DEVICE(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(${ftn}$_LIST_WRAPPER), INTENT (INOUT) :: SELF

#include "abor1.intfb.h"

    INTEGER (KIND=JPIM) :: JFLD
    CLASS (${ftn1}$), POINTER :: YLC

    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      CALL DEV_DEALLOCATE (SELF%DEVPTR)
      DO JFLD = 1, SIZE (SELF%CHILDREN)
        SELECT TYPE (YY => SELF%CHILDREN (JFLD)%PTR)
          CLASS IS (${ftn1}$)
            YLC => YY 
            NULLIFY (YLC%DEVPTR)
          CLASS DEFAULT
            CALL ABOR1 ('${ftn}$_LIST_WRAPPER_DELETE_DEVICE: UNEXPECTED CLASS')
        END SELECT
      ENDDO
    ENDIF

  END SUBROUTINE ${ftn}$_LIST_WRAPPER_DELETE_DEVICE

  SUBROUTINE ${ftn}$_SET_CHILD_DEVPTR (SELF, YDCHILD)
    CLASS(${ftn}$_LIST_WRAPPER), INTENT (INOUT) :: SELF
    CLASS(FIELD_BASIC), POINTER :: YDCHILD

#include "abor1.intfb.h"

    INTEGER (KIND=JPIM) :: JFLD
    INTEGER (KIND=JPIM) :: ICOUNT
    CLASS (${ftn1}$), POINTER :: YLC

    ICOUNT = 0

    DO JFLD = 1, SIZE (SELF%CHILDREN)
      IF (ASSOCIATED (YDCHILD, SELF%CHILDREN (JFLD))) THEN
        SELECT TYPE (YDCHILD)
          CLASS IS (${ftn1}$)
            YLC => YDCHILD
#:set ar = ', '.join ([':'] * (ft.rank-2))
            YLC%DEVPTR (${','.join (list (map (lambda i: "LBOUND(SELF%DEVPTR," + str(i) + "):", range (1, ft1.rank))))}$,1:) => SELF%DEVPTR (${ar}$, JFLD, :)
          CLASS DEFAULT
            CALL ABOR1 ('${ftn}$_SET_CHILD_DEVPTR: UNEXPECTED CLASS')
        END SELECT
        ICOUNT = ICOUNT + 1
      ENDIF
    ENDDO

    IF (ICOUNT /= 1) THEN
      CALL ABOR1 ('${ftn}$_SET_CHILD_DEVPTR: CHILD WAS NOT FOUND')
    ENDIF

  END SUBROUTINE

#:endif

END MODULE FIELD_${RANK}$${SUFF}$_LIST_MODULE
