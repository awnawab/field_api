#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE FIELD_GATHSCAT_TYPE_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList (hasView=True)

USE FIELD_MODULE
USE FIELD_ACCESS_MODULE
USE FIELD_FACTORY_MODULE
${fieldType.useParkind1 ()}$

#:for ft in fieldTypeList
USE ${ft.name}$_GATHSCAT_MODULE
#:endfor

IMPLICIT NONE

PRIVATE

TYPE FIELD_GATHSCAT
  INTEGER (KIND=JPIM) :: KGPBLKS_G = -1, KLON_G = -1, KGPTOT_G = -1
  INTEGER (KIND=JPIM) :: KGPBLKS_S = -1, KLON_S = -1, KGPTOT_S = -1
  LOGICAL :: LFULL = .FALSE.  ! No need to gather/scatter, all columns are OK, return pointers based on original fields
  LOGICAL :: LNULL = .FALSE.  ! No need to gather/scatter, all columns are KO, return pointers on empty arrays
  CLASS (FIELD_2LM), POINTER :: YLFCOND => NULL ()
  CLASS (FIELD_3IM), POINTER :: YLFINDS => NULL ()
#:for ft in fieldTypeList
  TYPE (${ft.name}$_GATHSCAT_PAIR), POINTER :: ${ft.name}$_LIST => NULL ()
#:endfor
CONTAINS
  PROCEDURE :: INIT => INIT_FIELD_GATHSCAT
  PROCEDURE :: SCATTER => SCATTER_FIELD_GATHSCAT
END TYPE FIELD_GATHSCAT

PUBLIC :: FIELD_GATHSCAT

INTEGER (KIND=JPIM), PARAMETER :: NLONDIM = 1, NBLKDIM = 2

CONTAINS

SUBROUTINE INIT_FIELD_GATHSCAT (SELF, YLFCOND, KGPTOT, KLON_S, KLON_G)

USE FIELD_ABORT_MODULE

CLASS (FIELD_GATHSCAT) :: SELF
CLASS (FIELD_2LM), POINTER, OPTIONAL :: YLFCOND
INTEGER (KIND=JPIM), INTENT (IN) :: KGPTOT
INTEGER (KIND=JPIM), INTENT (IN), OPTIONAL :: KLON_S, KLON_G

LOGICAL, POINTER :: LLF (:,:)
INTEGER (KIND=JPIM), POINTER :: INDS (:,:,:)
INTEGER (KIND=JPIM) :: JLONS, JBLKS, JLONG, JBLKG, I1S, I2S


IF (.NOT. PRESENT (YLFCOND)) THEN

  IF (.NOT. PRESENT (KLON_S)) CALL FIELD_ABORT ('INIT_FIELD_GATHSCAT: KLON_S IS REQUIRED')
  IF (.NOT. PRESENT (KLON_G)) CALL FIELD_ABORT ('INIT_FIELD_GATHSCAT: KLON_G IS REQUIRED')

  SELF%KGPTOT_S  = KGPTOT
  SELF%KLON_S    = KLON_S
  SELF%KGPBLKS_S = (SELF%KGPTOT_S+SELF%KLON_S-1) / SELF%KLON_S

  SELF%KGPTOT_G  = KGPTOT
  SELF%KLON_G    = KLON_G
  SELF%KGPBLKS_G = (SELF%KGPTOT_G+SELF%KLON_G-1) / SELF%KLON_G


! PRINT *, " KGPTOT_S  = ", SELF%KGPTOT_S  
! PRINT *, " KLON_S    = ", SELF%KLON_S    
! PRINT *, " KGPBLKS_S = ", SELF%KGPBLKS_S 

! PRINT *, " KGPTOT_G  = ", SELF%KGPTOT_G  
! PRINT *, " KLON_G    = ", SELF%KLON_G    
! PRINT *, " KGPBLKS_G = ", SELF%KGPBLKS_G 


  CALL FIELD_NEW (SELF%YLFINDS, UBOUNDS=[2, SELF%KLON_G, SELF%KGPBLKS_G], PERSISTENT=.TRUE.)
  INDS => GET_HOST_DATA_RDWR (SELF%YLFINDS)
  
  ! Create indices (serial code)
  
  JBLKG = 1
  JLONG = 1
  DO JBLKS = 1, SELF%KGPBLKS_S
    DO JLONS = 1, MIN (SELF%KLON_S, SELF%KGPTOT_S - (JBLKS - 1) * SELF%KLON_S)
      INDS (NLONDIM, JLONG, JBLKG) = JLONS
      INDS (NBLKDIM, JLONG, JBLKG) = JBLKS
      JLONG = JLONG + 1
      IF (JLONG > SELF%KLON_G) THEN
        JLONG = 1
        JBLKG = JBLKG + 1
      ENDIF
    ENDDO
  ENDDO
  
  IF (JBLKG <= SIZE (INDS, 3)) THEN
    DO WHILE (JLONG <= SELF%KLON_G)
      INDS (NLONDIM, JLONG, JBLKG) = -9999999
      INDS (NBLKDIM, JLONG, JBLKG) = -9999999
      JLONG = JLONG + 1
    ENDDO
  ENDIF
  
ELSE

  SELF%YLFCOND => YLFCOND

  LLF => GET_HOST_DATA_RDONLY (YLFCOND)

  SELF%KLON_S    = SIZE (LLF, 1)
  SELF%KGPBLKS_S = SIZE (LLF, 2)
  SELF%KGPTOT_S  = KGPTOT

  ! Reduction

  SELF%KGPTOT_G = 0

  DO JBLKS = 1, SELF%KGPBLKS_S
    I1S = 1
    I2S = MIN (SELF%KLON_S, SELF%KGPTOT_S - (JBLKS - 1) * SELF%KLON_S)
    SELF%KGPTOT_G = SELF%KGPTOT_G + COUNT (LLF (I1S:I2S,JBLKS))
  ENDDO


  IF (PRESENT (KLON_G)) THEN
    SELF%KLON_G = KLON_G
  ELSE
    SELF%KLON_G = SELF%KLON_S
  ENDIF

  SELF%KGPBLKS_G = (SELF%KGPTOT_G+SELF%KLON_G-1) / SELF%KLON_G
  
  SELF%LFULL = SELF%KGPTOT_G == SELF%KGPTOT_S
  SELF%LNULL = SELF%KGPTOT_G == 0
  
  IF (SELF%LNULL) THEN
    ! Do nothing
  ELSEIF (SELF%LFULL) THEN
    ! Do nothing
  ELSE
  
    CALL FIELD_NEW (SELF%YLFINDS, UBOUNDS=[2, SELF%KLON_G, SELF%KGPBLKS_G], PERSISTENT=.TRUE.)
    INDS => GET_HOST_DATA_RDWR (SELF%YLFINDS)
    
    ! Create indices (serial code)
  
    JBLKG = 1
    JLONG = 1
    DO JBLKS = 1, SELF%KGPBLKS_S
      DO JLONS = 1, MIN (SELF%KLON_S, SELF%KGPTOT_S - (JBLKS - 1) * SELF%KLON_S)
        IF (LLF (JLONS, JBLKS)) THEN
          IF ((JLONG > SIZE (INDS, 2)) .OR. (JBLKG > SIZE (INDS, 3))) THEN
            CALL FIELD_ABORT ('INIT_FIELD_GATHSCAT: OUT OF BOUNDS')
          ENDIF
          INDS (NLONDIM, JLONG, JBLKG) = JLONS
          INDS (NBLKDIM, JLONG, JBLKG) = JBLKS
          JLONG = JLONG + 1
          IF (JLONG > SELF%KLON_G) THEN
            JLONG = 1
            JBLKG = JBLKG + 1
          ENDIF
        ENDIF
      ENDDO
    ENDDO
    
    IF (JBLKG <= SIZE (INDS, 3)) THEN
      DO WHILE (JLONG <= SELF%KLON_G)
        INDS (NLONDIM, JLONG, JBLKG) = -9999999
        INDS (NBLKDIM, JLONG, JBLKG) = -9999999
        JLONG = JLONG + 1
      ENDDO
    ENDIF
  
  ENDIF

ENDIF

END SUBROUTINE

SUBROUTINE SCATTER_FIELD_GATHSCAT (SELF)
CLASS (FIELD_GATHSCAT) :: SELF
#:for ft in fieldTypeList
TYPE (${ft.name}$_GATHSCAT_PAIR), POINTER :: ${ft.name}$_LIST, ${ft.name}$_NEXT
#:endfor

IF (SELF%LNULL) THEN
  ! Do nothing
ELSEIF (SELF%LFULL) THEN
  ! Do nothing
ELSE

#:for ft in fieldTypeList
  CALL PAIR_SCATTER_DATA (SELF%${ft.name}$_LIST, SELF%YLFINDS)

#:endfor

  CALL FIELD_DELETE (SELF%YLFINDS)

ENDIF

SELF%YLFCOND => NULL ()
SELF%YLFINDS => NULL ()
SELF%KGPBLKS_G = -1 
SELF%KLON_G = -1 
SELF%KGPTOT_G = -1
SELF%KGPBLKS_S = -1 
SELF%KLON_S = -1 
SELF%KGPTOT_S = -1

END SUBROUTINE

END MODULE FIELD_GATHSCAT_TYPE_MODULE
