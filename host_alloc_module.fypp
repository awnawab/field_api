#! (C) Copyright 2022- ECMWF.
#! (C) Copyright 2022- Meteo-France.
#!
#! This software is licensed under the terms of the Apache Licence Version 2.0
#! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
#! In applying this licence, ECMWF does not waive the privileges and immunities
#! granted to it by virtue of its status as an intergovernmental organisation
#! nor does it submit to any jurisdiction.

MODULE HOST_ALLOC_MODULE

#:set fieldTypeList = fieldType.getFieldTypeList ()

${fieldType.useParkind1 ()}$
USE ISO_C_BINDING
#:if defined('CUDA')
USE CUDAFOR
#:endif
USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : INT64
USE FIELD_DEFAULTS_MODULE
USE FIELD_STATISTICS_MODULE
USE FIELD_ABORT_MODULE

IMPLICIT NONE

PRIVATE

INTERFACE HOST_ALLOC
#:for ft in fieldTypeList
  MODULE PROCEDURE ${ft.name}$_HOST_ALLOC
#:endfor
END INTERFACE HOST_ALLOC

INTERFACE HOST_ALLOC_POOLED
#:for ft in fieldTypeList
  MODULE PROCEDURE ${ft.name}$_HOST_ALLOC_POOLED
#:endfor
END INTERFACE HOST_ALLOC_POOLED

INTERFACE HOST_DEALLOC
#:for ft in fieldTypeList
  MODULE PROCEDURE ${ft.name}$_HOST_DEALLOC
#:endfor
END INTERFACE HOST_DEALLOC

INTERFACE HOST_DEALLOC_POOLED
#:for ft in fieldTypeList
  MODULE PROCEDURE ${ft.name}$_HOST_DEALLOC_POOLED
#:endfor
END INTERFACE HOST_DEALLOC_POOLED

INTERFACE
  SUBROUTINE C_MALLOC (SIZ, PTR) BIND (C, NAME='c_malloc')
    IMPORT :: C_PTR, C_SIZE_T
    INTEGER (C_SIZE_T), VALUE, INTENT(IN) :: SIZ
    TYPE (C_PTR), INTENT(OUT) :: PTR
  END SUBROUTINE C_MALLOC
  SUBROUTINE C_FREE (PTR) BIND (C, NAME='c_free')
    IMPORT :: C_PTR
    TYPE (C_PTR), VALUE, INTENT(IN) :: PTR
  END SUBROUTINE C_FREE
  SUBROUTINE C_PTR_INCR (SIZ, PTR) BIND (C, NAME='c_ptr_incr')
    IMPORT :: C_PTR, C_SIZE_T
    INTEGER (C_SIZE_T), VALUE, INTENT(IN) :: SIZ
    TYPE (C_PTR), INTENT(INOUT) :: PTR
  END SUBROUTINE C_PTR_INCR
  SUBROUTINE C_PTR_DECR (SIZ, PTR) BIND (C, NAME='c_ptr_decr')
    IMPORT :: C_PTR, C_SIZE_T
    INTEGER (C_SIZE_T), VALUE, INTENT(IN) :: SIZ
    TYPE (C_PTR), INTENT(INOUT) :: PTR
  END SUBROUTINE C_PTR_DECR
  SUBROUTINE PRINT_C_ADDR (PTR) BIND (C, name='print_c_addr')
    IMPORT :: C_PTR
    TYPE (C_PTR), INTENT(IN) :: PTR
  END SUBROUTINE PRINT_C_ADDR
END INTERFACE

TYPE :: MEM_POOL
  TYPE(C_PTR) :: DATA
  INTEGER :: PAD_LEN
  LOGICAL :: INITIALISED = .FALSE.
  LOGICAL :: AUTO_TEARDOWN = .TRUE.
  LOGICAL :: PINNED = .FALSE.
  INTEGER(KIND=INT64) :: POS = 0
  INTEGER(KIND=INT64) :: SIZE = 0

  CONTAINS

  PROCEDURE :: INIT => MEM_POOL_INIT
  PROCEDURE :: FINAL => MEM_POOL_FINAL
  PROCEDURE :: ALLOC => MEM_POOL_ALLOC
  PROCEDURE :: DEALLOC => MEM_POOL_DEALLOC

END TYPE MEM_POOL

TYPE(MEM_POOL) :: HOST_POOL

PUBLIC :: HOST_ALLOC
PUBLIC :: HOST_ALLOC_POOLED
PUBLIC :: HOST_DEALLOC
PUBLIC :: HOST_DEALLOC_POOLED
PUBLIC :: HOST_POOL

CONTAINS

SUBROUTINE MEM_POOL_INIT( SELF, PAD_LEN, AUTO_TEARDOWN )
   CLASS(MEM_POOL) :: SELF
   INTEGER, INTENT(IN) :: PAD_LEN
   LOGICAL, INTENT(IN) :: AUTO_TEARDOWN

   CHARACTER(LEN=20) :: HOST_POOL_SIZE
   INTEGER :: ISTAT

   SELF%PAD_LEN = PAD_LEN
   SELF%AUTO_TEARDOWN = AUTO_TEARDOWN

   CALL GET_ENVIRONMENT_VARIABLE('FIELD_API_HOST_POOL_SIZE', HOST_POOL_SIZE)

   IF( TRIM(HOST_POOL_SIZE) /= "" )THEN
      READ(HOST_POOL_SIZE, "(I20)") SELF%SIZE
   ELSE
     SELF%SIZE = 20_INT64*1024_INT64*1024_INT64*1024_INT64
   ENDIF

   CALL C_MALLOC(SELF%SIZE, SELF%DATA)

#:if defined('CUDA')
   IF(INIT_PINNED_VALUE)THEN
     CALL PIN_ALLOCATION(SELF%DATA, SELF%SIZE, ISTAT)
     IF (ISTAT /= 0) THEN
       CALL FIELD_ABORT ("MEM_POOL: FAILED TO REGISTER IN PAGE-LOCKED MEMORY")
     ENDIF
     SELF%PINNED = .TRUE.
   ENDIF
#:endif

END SUBROUTINE MEM_POOL_INIT

SUBROUTINE MEM_POOL_ALLOC( SELF, ARR_SIZE )
   CLASS(MEM_POOL) :: SELF
   INTEGER(C_SIZE_T), INTENT(IN) :: ARR_SIZE
   INTEGER(C_SIZE_T) :: ALLOC_SIZE

   ALLOC_SIZE = ARR_SIZE + MOD(ARR_SIZE, SELF%PAD_LEN)
   IF( ALLOC_SIZE + SELF%POS > SELF%SIZE)THEN
     CALL FIELD_ABORT ("MEM_POOL: ALLOCATION EXCEEDS SIZE OF POOL")
   ENDIF

   SELF%POS = SELF%POS + ALLOC_SIZE
   CALL C_PTR_INCR(ALLOC_SIZE, SELF%DATA)

END SUBROUTINE MEM_POOL_ALLOC

SUBROUTINE MEM_POOL_DEALLOC( SELF, ARR_SIZE )
   CLASS(MEM_POOL) :: SELF
   INTEGER(C_SIZE_T), INTENT(IN) :: ARR_SIZE
   INTEGER(C_SIZE_T) :: ALLOC_SIZE

   ALLOC_SIZE = ARR_SIZE + MOD(ARR_SIZE, SELF%PAD_LEN)

   CALL C_PTR_DECR(ALLOC_SIZE, SELF%DATA)
   SELF%POS = SELF%POS - ALLOC_SIZE

   IF( SELF%AUTO_TEARDOWN .AND. SELF%POS == 0 ) CALL SELF%FINAL()

END SUBROUTINE MEM_POOL_DEALLOC

SUBROUTINE MEM_POOL_FINAL( SELF )
   CLASS(MEM_POOL) :: SELF
   INTEGER :: ISTAT

   IF( .NOT. SELF%POS == 0 )THEN
      CALL FIELD_ABORT ("MEM_POOL: ALL FIELDS MUST BE DEALLOCATED BEFORE POOL CAN BE FREED")
   ENDIF

#:if defined('CUDA')
   IF (SELF%PINNED) THEN
     CALL UNPIN_ALLOCATION(SELF%DATA, ISTAT)
     IF (ISTAT /= 0) THEN
       CALL FIELD_ABORT ("MEM_POOL: FAILED TO UNREGISTER PAGE-LOCKED MEMORY")
     ENDIF
   ENDIF
#:endif

   CALL C_FREE(SELF%DATA)
   SELF%SIZE = 0
   SELF%INITIALISED = .FALSE.

END SUBROUTINE MEM_POOL_FINAL

#:if defined('CUDA')
SUBROUTINE PIN_ALLOCATION(DATA, ARR_SIZE, ISTAT)

   TYPE(C_PTR), INTENT(INOUT) :: DATA
   INTEGER, INTENT(OUT) :: ISTAT
   INTEGER(C_SIZE_T), INTENT(IN) :: ARR_SIZE

   ISTAT = CUDAHOSTREGISTER (DATA, ARR_SIZE, CUDAHOSTREGISTERMAPPED)

END SUBROUTINE PIN_ALLOCATION

SUBROUTINE UNPIN_ALLOCATION(DATA, ISTAT)

   TYPE(C_PTR), INTENT(INOUT) :: DATA
   INTEGER, INTENT(OUT) :: ISTAT

   ISTAT = CUDAHOSTUNREGISTER (DATA)

END SUBROUTINE UNPIN_ALLOCATION
#:endif

#:for ft in fieldTypeList
SUBROUTINE ${ft.name}$_HOST_ALLOC_POOLED (HST, LBOUNDS, UBOUNDS)

   ${ft.type}$, POINTER, INTENT(OUT) :: HST(${ft.shape}$)
   INTEGER(KIND=JPIM), INTENT(IN) :: LBOUNDS(${ft.rank}$)
   INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(${ft.rank}$)

   ${ft.type}$, POINTER :: PTR(${ft.shape}$)
   TYPE(C_PTR) :: DATA
   INTEGER(C_SIZE_T) :: ARR_SIZE
   INTEGER :: ISHAPE(${ft.rank}$), ISTAT

   ARR_SIZE = KIND(HST)
#:for r in range(ft.rank)
   ISHAPE(${r+1}$) = UBOUNDS(${r+1}$) - LBOUNDS(${r+1}$) + 1
   ARR_SIZE = ARR_SIZE * ISHAPE(${r+1}$)
#:endfor

   IF(ARR_SIZE > 0)THEN

     IF( .NOT. HOST_POOL%INITIALISED ) CALL HOST_POOL%INIT( POOL_PADDING_FACTOR, POOL_AUTO_TEARDOWN )

     CALL HOST_POOL%ALLOC(ARR_SIZE)
     CALL C_F_POINTER(HOST_POOL%DATA, PTR, SHAPE=ISHAPE)

     HST(${', '.join(map(lambda r: 'LBOUNDS('+str(r+1)+'):', range(0, ft.rank)))}$) => PTR
   ELSE
     ALLOCATE(HST(${','.join([f'LBOUNDS({r+1}):UBOUNDS({r+1})' for r in range(ft.rank)])}$))
   ENDIF

   IF (FIELD_STATISTICS_ENABLE) CALL FIELD_STATISTICS_HOST_ALLOCATE (SIZE (HST, KIND=JPIB) * INT (KIND (HST), KIND=JPIB))

END SUBROUTINE ${ft.name}$_HOST_ALLOC_POOLED

SUBROUTINE ${ft.name}$_HOST_ALLOC (HST, LBOUNDS, UBOUNDS, PINNED)

   ${ft.type}$, POINTER, INTENT(OUT) :: HST(${ft.shape}$)
   INTEGER(KIND=JPIM), INTENT(IN) :: LBOUNDS(${ft.rank}$)
   INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS(${ft.rank}$)
   LOGICAL, INTENT(IN) :: PINNED

   ${ft.type}$, POINTER :: PTR(${ft.shape}$)
   TYPE(C_PTR) :: DATA
   INTEGER(C_SIZE_T) :: ARR_SIZE
   INTEGER :: ISHAPE(${ft.rank}$), ISTAT

   ARR_SIZE = KIND(HST)
#:for r in range(ft.rank)
   ISHAPE(${r+1}$) = UBOUNDS(${r+1}$) - LBOUNDS(${r+1}$) + 1
   ARR_SIZE = ARR_SIZE * ISHAPE(${r+1}$)
#:endfor

   IF(ARR_SIZE > 0)THEN
     CALL C_MALLOC(ARR_SIZE, DATA)

#:if defined('CUDA')
     IF(PINNED)THEN
       CALL PIN_ALLOCATION(DATA, ARR_SIZE, ISTAT)
       IF (ISTAT /= 0) THEN
         CALL FIELD_ABORT ("${ft.name}$_OWNER: FAILED TO REGISTER IN PAGE-LOCKED MEMORY")
       ENDIF
     ENDIF
#:endif

     CALL C_F_POINTER(DATA, PTR, SHAPE=ISHAPE)
     HST(${', '.join(map(lambda r: 'LBOUNDS('+str(r+1)+'):', range(0, ft.rank)))}$) => PTR
   ELSE
     ALLOCATE(HST(${','.join([f'LBOUNDS({r+1}):UBOUNDS({r+1})' for r in range(ft.rank)])}$))
   ENDIF

   IF (FIELD_STATISTICS_ENABLE) CALL FIELD_STATISTICS_HOST_ALLOCATE (SIZE (HST, KIND=JPIB) * INT (KIND (HST), KIND=JPIB))

END SUBROUTINE ${ft.name}$_HOST_ALLOC

SUBROUTINE ${ft.name}$_HOST_DEALLOC(HST, PINNED)

   ${ft.type}$, POINTER, INTENT(INOUT) :: HST(${ft.shape}$)
   LOGICAL, INTENT (IN) :: PINNED

   TYPE(C_PTR) :: DATA
   INTEGER :: ISTAT
  
   IF (FIELD_STATISTICS_ENABLE) CALL FIELD_STATISTICS_HOST_DEALLOCATE (SIZE (HST, KIND=JPIB) * INT (KIND (HST), KIND=JPIB))

   IF(SIZE(HST) > 0)THEN
     DATA = C_LOC (HST (${ ', '.join (map (lambda i: 'LBOUND (HST, ' + str (i) + ')', range (1, ft.rank+1))) }$))

#:if defined('CUDA')
     IF (PINNED) THEN
       CALL UNPIN_ALLOCATION(DATA, ISTAT)
       IF (ISTAT /= 0) THEN
         CALL FIELD_ABORT ("${ft.name}$_OWNER: FAILED TO UNREGISTER PAGE-LOCKED MEMORY")
       ENDIF
     ENDIF
#:endif

     CALL C_FREE(DATA)
   ELSE
     DEALLOCATE(HST)
   ENDIF

   NULLIFY(HST)

END SUBROUTINE ${ft.name}$_HOST_DEALLOC

SUBROUTINE ${ft.name}$_HOST_DEALLOC_POOLED(HST)

   ${ft.type}$, POINTER, INTENT(INOUT) :: HST(${ft.shape}$)

   TYPE(C_PTR) :: DATA
   INTEGER(C_SIZE_T) :: ARR_SIZE
   INTEGER :: ISHAPE(${ft.rank}$)
   INTEGER :: UBOUNDS(${ft.rank}$)
   INTEGER :: LBOUNDS(${ft.rank}$)

  UBOUNDS = UBOUND(HST)
  LBOUNDS = LBOUND(HST)

   ARR_SIZE = KIND(HST)
#:for r in range(ft.rank)
   ISHAPE(${r+1}$) = UBOUNDS(${r+1}$) - LBOUNDS(${r+1}$) + 1
   ARR_SIZE = ARR_SIZE * ISHAPE(${r+1}$)
#:endfor
  
   IF (FIELD_STATISTICS_ENABLE) CALL FIELD_STATISTICS_HOST_DEALLOCATE (SIZE (HST, KIND=JPIB) * INT (KIND (HST), KIND=JPIB))

   IF(ARR_SIZE > 0)THEN
     CALL HOST_POOL%DEALLOC(ARR_SIZE)
   ELSE
     DEALLOCATE(HST)
   ENDIF

   NULLIFY(HST)

END SUBROUTINE ${ft.name}$_HOST_DEALLOC_POOLED

#:endfor

END MODULE HOST_ALLOC_MODULE
